<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>TTC Subway</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="stylesheet" href="style.css">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/Draggable.min.js"></script>
</head>

<body>

    <!-- MAP CONTAINER (Background) -->
    <div id="map-viewport">
        <!-- SVG Map Container -->
        <svg id="map-svg" viewBox="0 0 1000 800" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
            <g id="map-root">
                <g id="tracks-layer"></g>
                <g id="alerts-layer"></g>
                <g id="stations-layer"></g>
            </g>
        </svg>
    </div>

    <!-- UI OVERLAY LAYER -->
    <div class="ui-layer">

        <!-- Top Bar -->
        <div class="top-bar">
            <!-- Search Pill -->

            <!-- Info Button to replace Search -->
            <div class="fab-stack" style="margin-left: 0; margin-right: auto; pointer-events: auto;">
                <div class="fab" id="btn-info" style="margin-bottom:0;"><i class="fas fa-info-circle"></i></div>
            </div>

            <!-- Right Side FABs -->
            <div class="fab-stack">
                <div class="fab" id="btn-recenter"><i class="fas fa-crosshairs"></i></div>
                <div class="fab" id="btn-legend"><i class="fas fa-layer-group"></i></div>
            </div>
        </div>

        <!-- Bottom UI (Sheets + Nav) -->
        <div class="bottom-ui">

            <!-- ALERTS SHEET -->
            <div id="sheet-alerts" class="sheet-container">
                <div class="sheet-handle-area">
                    <div class="sheet-handle"></div>
                </div>
                <div class="sheet-header">
                    <div class="sheet-title">Active Alerts</div>
                    <div class="sheet-subtitle">Real-time service disruptions</div>
                </div>
                <div class="sheet-content" id="alerts-list">
                    <!-- Alert Cards Here -->
                </div>
            </div>

            <!-- UPCOMING SHEET -->
            <div id="sheet-upcoming" class="sheet-container">
                <div class="sheet-handle-area">
                    <div class="sheet-handle"></div>
                </div>
                <div class="sheet-header">
                    <div class="sheet-title">Upcoming</div>
                    <div class="sheet-subtitle">Planned closures & maintenance</div>
                </div>
                <div class="sheet-content" id="upcoming-list">
                    <!-- Upcoming Cards Here -->
                </div>
            </div>

            <!-- BOTTOM NAVIGATION -->
            <div class="bottom-nav">
                <div class="nav-item active" data-tab="map">
                    <i class="fas fa-map"></i>
                    <span>Map</span>
                </div>
                <div class="nav-item" data-tab="alerts">
                    <div style="position: relative;">
                        <i class="fas fa-exclamation-triangle"></i>
                        <span id="badge-active" class="nav-badge hidden">0</span>
                    </div>
                    <span>Alerts</span>
                </div>
                <div class="nav-item" data-tab="upcoming">
                    <div style="position: relative;">
                        <i class="fas fa-calendar-alt"></i>
                        <span id="badge-upcoming" class="nav-badge hidden">0</span>
                    </div>
                    <span>Upcoming</span>
                </div>
            </div>

        </div>
    </div>

    <!-- DISCLAIMER MODAL -->
    <div id="disclaimer-modal"
        style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; z-index:9999; background:rgba(0,0,0,0.8); align-items:center; justify-content:center; padding:20px;">
        <div
            style="background:var(--sidebar-bg); border:1px solid var(--border-color); padding:20px; border-radius:12px; max-width:400px; width:100%; color:white; font-family:'Inter', sans-serif;">
            <h2 style="margin-bottom:12px; font-weight:700; font-size:18px; color: var(--l1-color);">
                <i class="fas fa-exclamation-triangle" style="margin-right:8px;"></i>Disclaimer
            </h2>
            <p style="font-size:14px; line-height:1.5; color:#d1d5db; margin-bottom:12px;">
                This is a <strong>personal project</strong> and not an official TTC map. There could be mistakes.
            </p>
            <p style="font-size:14px; line-height:1.5; color:#d1d5db; margin-bottom:20px;">
                I made this because I was not able to easily know if an outage would affect me. I had to always look up
                a map to know, and this makes it easier to verify.
            </p>
            <button id="close-disclaimer"
                style="width:100%; padding:12px; background:var(--l4-color); border:none; border-radius:8px; color:white; font-weight:600; font-size:14px; cursor:pointer;">
                Close
            </button>
        </div>
    </div>

    <!-- MAIN APP SCRIPT -->
    <script>
        // --- State Management ---
        let activeTab = 'map';
        let activeAlerts = [];
        let upcomingAlerts = [];
        let mapDraggable = null;
        let pollingInterval = null;

        // --- DOM Elements ---
        const mapRoot = document.getElementById('map-root');
        const viewport = document.getElementById('map-viewport');
        const sheets = {
            alerts: document.getElementById('sheet-alerts'),
            upcoming: document.getElementById('sheet-upcoming')
        };
        const badges = {
            active: document.getElementById('badge-active'),
            upcoming: document.getElementById('badge-upcoming')
        };

        // --- Map Data (Simplified for brevity, but same logic) ---
        const rawMapData = [{ line: "1", stations: [{ name: "Vaughan Metropolitan Centre", x: 220, y: 50, accessible: !0 }, { name: "Highway 407", x: 240, y: 80, accessible: !0 }, { name: "Pioneer Village", x: 260, y: 110, accessible: !0 }, { name: "York University", x: 280, y: 140, accessible: !0 }, { name: "Finch West", x: 300, y: 170, accessible: !0 }, { name: "Downsview Park", x: 320, y: 200, accessible: !0 }, { name: "Sheppard West", x: 340, y: 230, accessible: !0 }, { name: "Wilson", x: 360, y: 260, accessible: !0 }, { name: "Yorkdale", x: 360, y: 290, accessible: !0 }, { name: "Lawrence West", x: 360, y: 320, accessible: !0 }, { name: "Glencairn", x: 360, y: 350, accessible: !1 }, { name: "Eglinton West", x: 360, y: 380, accessible: !0 }, { name: "St Clair West", x: 360, y: 410, accessible: !0 }, { name: "Dupont", x: 360, y: 440, accessible: !0 }, { name: "Spadina", x: 360, y: 500, interchange: !0, accessible: !0 }, { name: "St George", x: 400, y: 500, interchange: !0, accessible: !0 }, { name: "Museum", x: 400, y: 550, accessible: !1 }, { name: "Queen's Park", x: 400, y: 580, accessible: !0 }, { name: "St Patrick", x: 400, y: 610, accessible: !0 }, { name: "Osgoode", x: 400, y: 640, accessible: !0 }, { name: "St Andrew", x: 400, y: 670, accessible: !0 }, { name: "Union", x: 520, y: 700, accessible: !0 }, { name: "King", x: 640, y: 670, accessible: !1 }, { name: "Queen", x: 640, y: 640, accessible: !0 }, { name: "Dundas", x: 640, y: 610, accessible: !0 }, { name: "College", x: 640, y: 580, accessible: !1 }, { name: "Wellesley", x: 640, y: 550, accessible: !0 }, { name: "Bloor-Yonge", x: 640, y: 500, interchange: !0, accessible: !0 }, { name: "Rosedale", x: 640, y: 460, accessible: !1 }, { name: "Summerhill", x: 640, y: 430, accessible: !1 }, { name: "St Clair", x: 640, y: 400, accessible: !0 }, { name: "Davisville", x: 640, y: 370, accessible: !0 }, { name: "Eglinton", x: 640, y: 340, accessible: !0 }, { name: "Lawrence", x: 640, y: 310, accessible: !0 }, { name: "York Mills", x: 640, y: 280, accessible: !0 }, { name: "Sheppard-Yonge", x: 640, y: 200, interchange: !0, accessible: !0 }, { name: "North York Centre", x: 640, y: 150, accessible: !0 }, { name: "Finch", x: 640, y: 100, accessible: !0 }] }, { line: "2", stations: [{ name: "Kipling", x: 30, y: 500, accessible: !0 }, { name: "Islington", x: 53, y: 500, accessible: !1 }, { name: "Royal York", x: 76, y: 500, accessible: !0 }, { name: "Old Mill", x: 99, y: 500, accessible: !1 }, { name: "Jane", x: 122, y: 500, accessible: !0 }, { name: "Runnymede", x: 145, y: 500, accessible: !0 }, { name: "High Park", x: 168, y: 500, accessible: !1 }, { name: "Keele", x: 191, y: 500, accessible: !0 }, { name: "Dundas West", x: 214, y: 500, accessible: !0 }, { name: "Lansdowne", x: 237, y: 500, accessible: !1 }, { name: "Dufferin", x: 260, y: 500, accessible: !0 }, { name: "Ossington", x: 283, y: 500, accessible: !0 }, { name: "Christie", x: 306, y: 500, accessible: !1 }, { name: "Bathurst", x: 329, y: 500, accessible: !0 }, { name: "Spadina", x: 360, y: 500, interchange: !0, accessible: !0 }, { name: "St George", x: 400, y: 500, interchange: !0, accessible: !0 }, { name: "Bay", x: 520, y: 500, accessible: !0 }, { name: "Bloor-Yonge", x: 640, y: 500, interchange: !0, accessible: !0 }, { name: "Sherbourne", x: 670, y: 500, accessible: !0 }, { name: "Castle Frank", x: 695, y: 500, accessible: !1 }, { name: "Broadview", x: 720, y: 500, accessible: !0 }, { name: "Chester", x: 745, y: 500, accessible: !0 }, { name: "Pape", x: 770, y: 500, accessible: !0 }, { name: "Donlands", x: 795, y: 500, accessible: !1 }, { name: "Greenwood", x: 820, y: 500, accessible: !1 }, { name: "Coxwell", x: 845, y: 500, accessible: !0 }, { name: "Woodbine", x: 870, y: 500, accessible: !0 }, { name: "Main Street", x: 895, y: 500, accessible: !0 }, { name: "Victoria Park", x: 920, y: 500, accessible: !0 }, { name: "Warden", x: 945, y: 500, accessible: !1 }, { name: "Kennedy", x: 970, y: 500, accessible: !0 }] }, { line: "4", stations: [{ name: "Sheppard-Yonge", x: 640, y: 200, interchange: !0, accessible: !0 }, { name: "Bayview", x: 690, y: 200, accessible: !0 }, { name: "Bessarion", x: 740, y: 200, accessible: !0 }, { name: "Leslie", x: 790, y: 200, accessible: !0 }, { name: "Don Mills", x: 840, y: 200, accessible: !0 }] }];


        // --- Initialization ---
        function init() {
            renderMap();
            renderMap();
            setupDragAndZoom();
            setupPinchZoom();
            fetchData();
            fetchData();
            pollingInterval = setInterval(fetchData, 60000);

            // Disclaimer Logic
            const modal = document.getElementById('disclaimer-modal');
            const btnInfo = document.getElementById('btn-info');
            const btnClose = document.getElementById('close-disclaimer');

            if (btnInfo && modal && btnClose) {
                btnInfo.addEventListener('click', () => {
                    modal.style.display = 'flex';
                });
                btnClose.addEventListener('click', () => {
                    modal.style.display = 'none';
                });
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) modal.style.display = 'none';
                });
            }
        }

        // --- Navigation Logic ---
        document.querySelectorAll('.nav-item').forEach(item => {
            item.addEventListener('click', () => {
                const tab = item.dataset.tab;
                switchTab(tab);
            });
        });

        function switchTab(tab) {
            // Update Icons
            document.querySelectorAll('.nav-item').forEach(el => el.classList.remove('active'));
            const activeNav = document.querySelector(`.nav-item[data-tab="${tab}"]`);
            if (activeNav) activeNav.classList.add('active');

            // Handle Sheets
            Object.values(sheets).forEach(s => s.classList.remove('active'));
            if (tab === 'alerts' || tab === 'upcoming') {
                if (sheets[tab]) sheets[tab].classList.add('active');
            }

            activeTab = tab;
        }

        // --- Map Rendering ---
        function renderMap() {
            const tracks = document.getElementById('tracks-layer');
            const stations = document.getElementById('stations-layer');

            // Render Tracks
            rawMapData.forEach(lineData => {
                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                path.setAttribute("d", getPathFromStations(lineData.stations, lineData.line));
                path.setAttribute("class", `track line-${lineData.line}`);
                tracks.appendChild(path);
            });

            // Render Stations
            rawMapData.forEach(l => {
                l.stations.forEach((s, i) => {
                    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
                    g.setAttribute("transform", `translate(${s.x}, ${s.y})`);

                    // Markers
                    if (i === 0 || i === l.stations.length - 1) { // Terminals
                        const c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                        c.setAttribute("r", 14); c.setAttribute("fill", getLineColor(l.line)); c.setAttribute("stroke", "white"); c.setAttribute("stroke-width", 3);
                        g.appendChild(c);
                        const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
                        t.textContent = l.line; t.setAttribute("class", "terminal-text"); t.setAttribute("fill", l.line === '1' ? 'black' : 'white');
                        g.appendChild(t);
                    } else if (s.interchange) {
                        const gIcon = document.createElementNS("http://www.w3.org/2000/svg", "g"); gIcon.setAttribute("class", "station-marker");
                        const sticker = document.createElementNS("http://www.w3.org/2000/svg", "circle"); sticker.setAttribute("r", 13); sticker.setAttribute("fill", "white"); gIcon.appendChild(sticker);
                        const blackRing = document.createElementNS("http://www.w3.org/2000/svg", "circle"); blackRing.setAttribute("r", 11); blackRing.setAttribute("fill", "black"); gIcon.appendChild(blackRing);
                        const whiteGap = document.createElementNS("http://www.w3.org/2000/svg", "circle"); whiteGap.setAttribute("r", 7.5); whiteGap.setAttribute("fill", "white"); gIcon.appendChild(whiteGap);
                        const blueBtn = document.createElementNS("http://www.w3.org/2000/svg", "circle"); blueBtn.setAttribute("r", 6); blueBtn.setAttribute("fill", "#528CCB"); gIcon.appendChild(blueBtn);
                        const iconPath = document.createElementNS("http://www.w3.org/2000/svg", "path"); iconPath.setAttribute("d", "M12 3a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3m-.663 2.146a1.5 1.5 0 0 0-.47-2.115l-2.5-1.508a1.5 1.5 0 0 0-1.676.086l-2.329 1.75a.866.866 0 0 0 1.051 1.375L7.361 3.37l.922.71-2.038 2.445A4.73 4.73 0 0 0 2.628 7.67l1.064 1.065a3.25 3.25 0 0 1 4.574 4.574l1.064 1.063a4.73 4.73 0 0 0 1.09-3.998l1.043-.292-.187 2.991a.872.872 0 1 0 1.741.098l.206-4.121A1 1 0 0 0 12.224 8h-2.79zM3.023 9.48a3.25 3.25 0 0 0 4.496 4.496l1.077 1.077a4.75 4.75 0 0 1-6.65-6.65z"); iconPath.setAttribute("fill", "white"); iconPath.setAttribute("transform", "translate(-4.8, -4.8) scale(0.6)"); gIcon.appendChild(iconPath);
                        g.appendChild(gIcon);
                    } else if (s.accessible) {
                        const gIcon = document.createElementNS("http://www.w3.org/2000/svg", "g");
                        const outerRing = document.createElementNS("http://www.w3.org/2000/svg", "circle"); outerRing.setAttribute("r", "4.5"); outerRing.setAttribute("fill", "black"); gIcon.appendChild(outerRing);
                        const midRing = document.createElementNS("http://www.w3.org/2000/svg", "circle"); midRing.setAttribute("r", "3.8"); midRing.setAttribute("fill", "white"); gIcon.appendChild(midRing);
                        const innerCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle"); innerCircle.setAttribute("r", "3"); innerCircle.setAttribute("fill", "#528CCB"); gIcon.appendChild(innerCircle);
                        const iconPath = document.createElementNS("http://www.w3.org/2000/svg", "path"); iconPath.setAttribute("d", "M12 3a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3m-.663 2.146a1.5 1.5 0 0 0-.47-2.115l-2.5-1.508a1.5 1.5 0 0 0-1.676.086l-2.329 1.75a.866.866 0 0 0 1.051 1.375L7.361 3.37l.922.71-2.038 2.445A4.73 4.73 0 0 0 2.628 7.67l1.064 1.065a3.25 3.25 0 0 1 4.574 4.574l1.064 1.063a4.73 4.73 0 0 0 1.09-3.998l1.043-.292-.187 2.991a.872.872 0 1 0 1.741.098l.206-4.121A1 1 0 0 0 12.224 8h-2.79zM3.023 9.48a3.25 3.25 0 0 0 4.496 4.496l1.077 1.077a4.75 4.75 0 0 1-6.65-6.65z"); iconPath.setAttribute("fill", "white"); iconPath.setAttribute("transform", "translate(-2, -2) scale(0.25)"); gIcon.appendChild(iconPath);
                        g.appendChild(gIcon);
                    } else {
                        const c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                        c.setAttribute("r", 4); c.setAttribute("fill", "white");
                        g.appendChild(c);
                    }

                    // Labels - Restoring comprehensive logic
                    // Labels - Prevent duplicates at interchanges
                    // Skip Line 4 Sheppard-Yonge (use Line 1)
                    // Skip Line 1 Spadina, St George, Bloor-Yonge (use Line 2 rotated)
                    const isDup = (l.line === '4' && s.name === "Sheppard-Yonge") ||
                        (l.line === '1' && ["Spadina", "St George", "Bloor-Yonge"].includes(s.name));

                    if (!isDup) {

                        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                        text.textContent = s.name;
                        text.setAttribute("class", "station-label");

                        let tx = 15, ty = 5, rot = 0, anchor = "start";

                        // Custom adjustments for specific lines and layout areas
                        if (l.line === '1') {
                            if (s.name === "Union") { tx = 0; ty = 28; anchor = "middle"; }
                            else if (s.name === "St Andrew" || s.name === "Wellesley" || s.name === "Sheppard-Yonge") { tx = -15; ty = 5; anchor = "end"; }
                            else if (s.x < 360) { tx = -15; ty = 5; anchor = "end"; } // West side of U
                            else if (s.x >= 640 && s.y < 500) { tx = 15; ty = 5; anchor = "start"; } // East side of U
                        } else if (l.line === '2') {
                            // Rotate Line 2 labels to avoid track collision
                            if (s.name === 'St George') {
                                rot = -45; tx = 10; ty = -10; anchor = "start";
                            } else if (s.name === 'Spadina') {
                                rot = 45; tx = -10; ty = -10; anchor = "end";
                            } else {
                                rot = 45; tx = 10; ty = 10; anchor = "start";
                            }
                        }

                        // Line 4 diagonal
                        if (l.line === '4' || (l.line === '1' && s.y > 680 && s.name !== 'Union')) {
                            // No diagonal rotation for Line 1 bottom curve usually, but Line 4 needs it
                            if (l.line === '4') { rot = 45; tx = 10; ty = 10; anchor = "start"; }
                        }

                        text.setAttribute("text-anchor", anchor);
                        if (rot !== 0) text.setAttribute("transform", `rotate(${rot}) translate(${tx}, ${ty})`);
                        else text.setAttribute("transform", `translate(${tx}, ${ty})`);

                        // Group text in a g to handle position relative to station g
                        const tg = document.createElementNS("http://www.w3.org/2000/svg", "g");
                        tg.appendChild(text);
                        g.appendChild(tg);
                    }

                    stations.appendChild(g);
                });
            });

            // GSAP Draggable
            // Dynamic Initial Fit
            const mapWidth = 1000;
            const mapHeight = 800;
            const containerWidth = window.innerWidth;
            const containerHeight = window.innerHeight;

            // Calculate "Cover" or "Contain" scale manually to ensure U-shape is visible
            // We want to ensure the width of the map (1000) fits within the container width with some padding?
            // Or better, let's start with a scale that fits the WIDTH of the content (approx 800px wide for the U)
            // The U-shape is roughly from x=200 to x=900. width=700.

            let initialScale = containerWidth / 1000;
            if (containerWidth < 500) initialScale = containerWidth / 600; // Zoom in more on mobile (crop sides slightly)

            // Initial Centering
            // Convert SVG coords to viewport coords at this scale
            const svgCenterX = 500 * initialScale;
            const svgCenterY = 400 * initialScale;
            const screenCenterX = containerWidth / 2;
            const screenCenterY = containerHeight / 2;

            const initialX = screenCenterX - svgCenterX;
            const initialY = screenCenterY - svgCenterY;

            gsap.set(mapRoot, { x: initialX, y: initialY, scale: initialScale });

            mapDraggable = Draggable.create(mapRoot, {
                type: "x,y",
                bounds: { minX: -1000, maxX: 1000, minY: -1000, maxY: 1000 },
                inertia: true,
                edgeResistance: 0.65,
                trigger: viewport
            })[0];

            // Recenter Button
            document.getElementById('btn-recenter').addEventListener('click', () => {
                gsap.to(mapRoot, { x: 0, y: 0, scale: 1, duration: 0.6, ease: "power2.out" });
            });
        }

        // --- Path Logic (with Union Curve Fix) ---
        function getPathFromStations(stations, lineId) {
            let d = "";
            for (let i = 0; i < stations.length; i++) {
                const s = stations[i];
                if (i === 0) { d += `M ${s.x} ${s.y} `; continue; }

                // Curve Logic
                if (lineId === '1') {
                    if (s.name === 'Union') {
                        // Curve into Union from St Andrew
                        d += `Q 400 700, 520 700 `;
                        continue;
                    }
                    if (s.name === 'King') {
                        // Curve out of Union to King
                        d += `Q 640 700, 640 670 `;
                        continue;
                    }
                }
                d += `L ${s.x} ${s.y} `;
            }
            return d;
        }

        function getLineColor(id) {
            if (id === '1') return '#FFC425';
            if (id === '2') return '#009639';
            if (id === '4') return '#A319FF';
            return 'white';
        }

        // --- Data Fetching ---
        async function fetchData() {
            try {
                const [res1, res2] = await Promise.all([
                    fetch('/api/alerts'),
                    fetch('/api/upcoming-alerts')
                ]);
                activeAlerts = await res1.json();
                upcomingAlerts = await res2.json();

                renderAlertsOnMap();
                renderLists();
                updateBadges();
            } catch (e) { console.warn("Fetch error", e); }
        }

        function renderAlertsOnMap() {
            const layer = document.getElementById('alerts-layer');
            layer.innerHTML = '';

            // Only render active alerts on the map
            const mapActiveAlerts = activeAlerts.filter(alert => alert.status === 'active');
            mapActiveAlerts.forEach(alert => {
                const isDelay = alert.effect === 'SIGNIFICANT_DELAYS' || alert.effect === 'REDUCED_SPEED';
                if (alert.singleStation) drawStationAlert(alert.line, alert.start, isDelay);
                else {
                    const flow = calculateFlow(alert.line, alert.start, alert.end, alert.direction);
                    drawAlertPath(alert.line, alert.start, alert.end, flow, alert.shuttle, isDelay);
                }
            });
        }

        function calculateFlow(line, startName, endName, direction) {
            if (direction === 'Both Ways') return 'both';
            const lineObj = rawMapData.find(l => l.line === line); if (!lineObj) return 'forward';
            const idx1 = lineObj.stations.findIndex(s => s.name === startName); const idx2 = lineObj.stations.findIndex(s => s.name === endName);
            if (direction && line === '1') {
                const unionIdx = 21; const midIdx = (idx1 + idx2) / 2;
                if (midIdx < unionIdx) {
                    if (direction === 'Northbound') return 'reverse'; if (direction === 'Southbound') return 'forward';
                } else {
                    if (direction === 'Northbound') return 'forward'; if (direction === 'Southbound') return 'reverse';
                }
            }
            if (idx1 < idx2) return 'forward'; return 'reverse';
        }

        function drawAlertPath(line, startName, endName, flow, isShuttle, isDelay) {
            const layer = document.getElementById('alerts-layer');
            const lineObj = rawMapData.find(l => l.line === line); if (!lineObj) return;
            const idx1 = lineObj.stations.findIndex(s => s.name === startName); const idx2 = lineObj.stations.findIndex(s => s.name === endName);
            if (idx1 === -1 || idx2 === -1) return;
            const segment = lineObj.stations.slice(Math.min(idx1, idx2), Math.max(idx1, idx2) + 1);
            const d = getPathFromStations(segment, line);
            if (isShuttle) {
                const shuttlePath = document.createElementNS("http://www.w3.org/2000/svg", "path");
                shuttlePath.setAttribute("d", d); shuttlePath.setAttribute("class", "shuttle-outline"); layer.appendChild(shuttlePath);
            }
            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute("d", d); path.setAttribute("class", "alert-base");
            if (isDelay) path.classList.add("delay");

            if (flow === 'both') path.classList.add("pulse-solid"); else if (flow === 'reverse') path.classList.add("flow-reverse"); else path.classList.add("flow-forward");
            layer.appendChild(path);
        }

        function drawStationAlert(line, stationName, isDelay) {
            const layer = document.getElementById('alerts-layer');
            const lineObj = rawMapData.find(l => l.line === line); if (!lineObj) return;
            const s = lineObj.stations.find(st => st.name === stationName); if (!s) return;
            const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            circle.setAttribute("cx", s.x); circle.setAttribute("cy", s.y); circle.setAttribute("r", 10); circle.setAttribute("class", "station-alert-glow");
            if (isDelay) circle.style.stroke = "var(--delay-color)";
            if (isDelay) circle.style.fill = "var(--delay-color)";
            layer.appendChild(circle);
        }


        function renderLists() {
            // Alerts List
            const alertsHtml = activeAlerts.length ? activeAlerts.map(a => createAlertCard(a)).join('') : '<div style="text-align:center; padding:20px; color:gray">No active alerts</div>';
            document.getElementById('alerts-list').innerHTML = alertsHtml;

            // Upcoming List
            const upcomingHtml = upcomingAlerts.length ? upcomingAlerts.map(a => createAlertCard(a, true)).join('') : '<div style="text-align:center; padding:20px; color:gray">No upcoming alerts</div>';
            document.getElementById('upcoming-list').innerHTML = upcomingHtml;
        }

        function createAlertCard(a, isUpcoming = false) {
            const color = (a.effect === 'SIGNIFICANT_DELAYS') ? 'bg-l1' : 'bg-alert';
            // Simplified logic for demo color mapping
            const badgeClass = a.line === '1' ? 'bg-l1' : a.line === '2' ? 'bg-l2' : 'bg-l4';

            return `
            <div class="alert-card">
                <div class="alert-header">
                    <div class="line-badge ${badgeClass}">${a.line}</div>
                    <div style="font-weight:600; font-size:15px;">${a.reason}</div>
                </div>
                <div class="alert-body">
                    <div style="margin-bottom:6px; color:white; font-size:13px;">
                        ${a.singleStation ? `At ${a.start}` : `${a.start} â†” ${a.end}`}
                    </div>
                    ${a.originalText}
                    ${a.shuttle ? '<div class="shuttle-tag"><i class="fas fa-bus"></i> Shuttle Bus</div>' : ''}
                </div>
            </div>`;
        }

        function updateBadges() {
            const countActive = activeAlerts.length;
            const countFuture = upcomingAlerts.length;

            badges.active.innerText = countActive;
            badges.active.classList.toggle('hidden', countActive === 0);

            badges.upcoming.innerText = countFuture;
            badges.upcoming.classList.toggle('hidden', countFuture === 0);
        }

        // --- Interactions (Ported from Desktop) ---
        function setupDragAndZoom() {
            if (typeof gsap === 'undefined' || typeof Draggable === 'undefined') return;
            gsap.set(mapRoot, { x: 0, y: 0, scale: 1 });
            mapDraggable = Draggable.create(mapRoot, {
                type: "x,y",
                inertia: true,
                trigger: viewport,
                edgeResistance: 0.65,
                onDragStart: () => updateMapBounds(), // Ensure bounds are fresh
            })[0];

            // Initial bounds setup
            updateMapBounds();

            window.addEventListener('resize', updateMapBounds);
        }

        function setupPinchZoom() {
            let initialDistance = 0;
            let initialScale = 1;

            viewport.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    initialDistance = getDistance(e.touches[0], e.touches[1]);
                    initialScale = gsap.getProperty(mapRoot, "scale");
                }
            });

            viewport.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    const currentDistance = getDistance(e.touches[0], e.touches[1]);
                    const scale = (currentDistance / initialDistance) * initialScale;
                    const clampedScale = Math.min(Math.max(0.4, scale), 8);

                    // Simple scale set. Ideally we should zoom towards the center of the pinch, 
                    // but for now let's just ensure bounds are respected.
                    gsap.set(mapRoot, { scale: clampedScale });
                    updateMapBounds();
                }
            }, { passive: false });

            function getDistance(touch1, touch2) {
                const dx = touch1.clientX - touch2.clientX;
                const dy = touch1.clientY - touch2.clientY;
                return Math.sqrt(dx * dx + dy * dy);
            }
        }

        function getMapBounds(scale) {
            const mapWidth = 1000 * scale;
            const mapHeight = 800 * scale;

            // Calculate the current visual scale of the SVG relative to the viewport
            // The SVG uses preserveAspectRatio="xMidYMid meet"
            const svgScale = Math.min(viewport.clientWidth / 1000, viewport.clientHeight / 800);

            // Convert viewport dimensions to SVG user units
            const scaledViewportWidth = viewport.clientWidth / svgScale;
            const scaledViewportHeight = viewport.clientHeight / svgScale;

            let minX, maxX, minY, maxY;

            const WIGGLE_ROOM = 100; // Pixels of wiggle room

            // Horizontal Bounds (in SVG User Units)
            if (mapWidth < scaledViewportWidth) {
                // Center map if smaller than viewport but allow wiggle
                const centerX = (scaledViewportWidth - mapWidth) / 2;
                minX = centerX - WIGGLE_ROOM;
                maxX = centerX + WIGGLE_ROOM;
            } else {
                minX = scaledViewportWidth - mapWidth - WIGGLE_ROOM;
                maxX = WIGGLE_ROOM;
            }

            // Vertical Bounds (in SVG User Units)
            if (mapHeight < scaledViewportHeight) {
                // Center map vertically but allow wiggle
                const centerY = (scaledViewportHeight - mapHeight) / 2;
                minY = centerY - WIGGLE_ROOM;
                maxY = centerY + WIGGLE_ROOM;
            } else {
                minY = scaledViewportHeight - mapHeight - WIGGLE_ROOM;
                maxY = WIGGLE_ROOM;
            }

            return { minX, maxX, minY, maxY };
        }

        function updateMapBounds(specificScale) {
            if (!mapDraggable) return;

            const currentScale = gsap.getProperty(mapRoot, "scale");
            const scale = specificScale || currentScale;

            const bounds = getMapBounds(scale);

            mapDraggable.applyBounds(bounds);

            // If we are not currently animating (e.g. pinch zoom or window resize), 
            // and the specificScale matches current (or wasn't provided), 
            // enforce bounds on the element position immediately.
            // This prevents "stuck out of bounds" state which causes rubber banding on next drag.
            if (!gsap.isTweening(mapRoot) && (!specificScale || Math.abs(specificScale - currentScale) < 0.001)) {
                const currX = gsap.getProperty(mapRoot, "x");
                const currY = gsap.getProperty(mapRoot, "y");

                let fixX = currX;
                let fixY = currY;

                if (fixX < bounds.minX) fixX = bounds.minX;
                if (fixX > bounds.maxX) fixX = bounds.maxX;
                if (fixY < bounds.minY) fixY = bounds.minY;
                if (fixY > bounds.maxY) fixY = bounds.maxY;

                if (fixX !== currX || fixY !== currY) {
                    gsap.set(mapRoot, { x: fixX, y: fixY });
                }
            }
        }

        window.onload = init;
    </script>
</body>

</html>